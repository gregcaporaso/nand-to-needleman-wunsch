#!/usr/bin/env python

import sys
import os
import pathlib
from enum import Enum
from collections import namedtuple



def _print_usage(program_name):
    usage = (
        f"\n{program_name} usage instructions:\n\n"
        f"  {program_name} (--help | -h)\n"
        f"     print help text and exit\n\n"
        f"  {program_name} (--verbose) in.asm\n"
        f"     assemble in.asm to in.hack\n\n"
        f"  {program_name} (--verbose) my/path/in.asm\n"
        f"     assemble my/path/in.asm to my/path/in.hack\n\n"
        "✌️")
    print(usage)

Command = namedtuple('Command', ['type', 'operation', 'args'])

C = Enum('CommandType',
         ['ARITHMETIC',
          'PUSH',
          'POP',
          'LABEL',
          'GOTO',
          'IF',
          'FUNCTION',
          'RETURN',
          'CALL'])

class VMParser(object):

    _command_map = {'add' : (C.ARITHMETIC, 0),
                    'sub' : (C.ARITHMETIC, 0),
                    'and' : (C.ARITHMETIC, 0),
                    'or'  : (C.ARITHMETIC, 0),
                    'eq'  : (C.ARITHMETIC, 0),
                    'gt'  : (C.ARITHMETIC, 0),
                    'lt'  : (C.ARITHMETIC, 0),
                    'not' : (C.ARITHMETIC, 0),
                    'neg' : (C.ARITHMETIC, 0),
                    'push': (C.PUSH, 2),
                    'pop' : (C.POP,  2)
                    }

    def __init__(self, inf):
        self.inf = inf
        self.line_number = 0

    def __call__(self):
        for line in self.inf:
            self.line_number += 1
            line = self._clean_line(line)
            if len(line) == 0 or line.startswith('//'):
                continue
            else:
                command = self._parse_command(line.split())
                yield command

    def _parse_command(self, fields):
        try:
            command_type, expected_n_args = self._command_map[fields[0]]
        except KeyError:
            self._raise_error(f"Unknown command type: {fields[0]}")

        if len(fields[1:]) != expected_n_args:
               self._raise_error(
                   f"Expected {expected_n_args} arguments for command "
                   f"{fields[0]}, but received "
                   f"{len(fields[1:])}: {' '.join(fields)}")

        return Command(type=command_type,
                       operation=fields[0],
                       args=fields[1:])

    def _clean_line(self, line):
        return line.strip().split('//')[0]

    def _raise_error(self,
                     message):
        raise ValueError(f'Line {self.line_number}: {message}')


class AsmWriter(object):

    def __init__(self, outf):
        self.outf = outf
        self.command_number = 0

    def __call__(self, command):
        self._comment(f"Start {command.type}")
        self._comment(" ".join([command.operation,
                                " ".join(command.args)]))

        if command.type == C.PUSH:
            self._push(command)
        elif command.type == C.ARITHMETIC:
            self._arithmetic(command)
        else:
            raise NotImplementedError(
                f"Unknown command type: {command.type}")

        self._comment(f"End {command.type}", double_newline=True)

    def _push(self, command):
        if command.args[0] == 'constant':
            self._command(f"@{command.args[1]}")
            self._command("D = A")
            self._command("@SP")
            self._command("A = M")
            self._command("M = D")

            self._increment_stack_pointer()
        else:
            raise NotImplementedError(
                f"Unknown push command source: {command.args[0]}")

    def _arithmetic(self, command):
        if command.operation == 'add':
            self._decrement_stack_pointer()

            self._command("@SP")
            self._command("A = M")
            self._command("D = M")

            self._decrement_stack_pointer()

            self._command("@SP")
            self._command("A = M")
            self._command(f"M = M + D")

            self._increment_stack_pointer()
        else:
            raise NotImplementedError(
                f"Unknown arithmetic command: {command.operation}")

    def finalize_program(self):
        self._comment("End program")

        self._command("(INFINITE_LOOP)")
        self._command("@INFINITE_LOOP")
        self._command("0;JMP")

    def _comment(self, comment, double_newline=False):
        self.outf.write(f"// {comment}\n")
        if double_newline:
            self.outf.write(f"\n")

    def _command(self, command):
        self.outf.write(f"{command}\n")

    def _increment_stack_pointer(self):
        self._comment("SP++")
        self._command("@SP")
        self._command("M = M + 1")

    def _decrement_stack_pointer(self):
        self._comment("SP--")
        self._command("@SP")
        self._command("M = M - 1")


def vm_translator(input_fp,
                  output_fp,
                  verbose=False):
    """
    """
    with open(input_fp) as inf, \
         open(output_fp, 'w') as outf:

        vm_parser = VMParser(inf)
        asm_writer = AsmWriter(outf)

        for command in vm_parser():
            if verbose:
                print(
                 f"{command.type}: "
                 f"{command.operation} {' '.join(command.arguments)}")
            asm_writer(command)

        asm_writer.finalize_program()


if __name__ == "__main__":
    if len(sys.argv) == 1 or '--help' in sys.argv or '-h' in sys.argv:
        _print_usage(program_name=pathlib.Path(sys.argv[0]).name)
        exit(0)

    verbose = '--verbose' in sys.argv

    input_fp = pathlib.Path(sys.argv[-1])

    if not input_fp.exists():
        raise ValueError(f"Input path doesn't exist: {input_fp}")

    if not input_fp.suffix == '.vm':
        raise ValueError(
            "Input path must have extension .vm, "
            f"but found {input_fp.suffix}")

    output_fp = input_fp.with_suffix('.asm')

    if verbose:
        print(f"Input path: {input_fp}")
        print(f"Output path: {output_fp}")

    vm_translator(input_fp, output_fp, verbose=verbose)