#!/usr/bin/env python

import sys
import os
import pathlib

def _print_usage(program_name):
    usage = (
        f"\n{program_name} usage instructions:\n\n"
        f"  {program_name} (--help | -h)\n"
        f"     print help text and exit\n\n"
        f"  {program_name} (--verbose) in.asm\n"
        f"     assemble in.asm to in.hack\n\n"
        f"  {program_name} (--verbose) my/path/in.asm\n"
        f"     assemble my/path/in.asm to my/path/in.hack\n\n"
        "✌️")
    print(usage)

def _raise_error(message, line_number):
    raise ValueError(f'Line {line_number}: {message}')

def _write_asm_comment(outf, comment):
    outf.write(f"// {comment}\n")

def _write_asm_instruction(outf, instruction):
    outf.write(f"{instruction}\n")

def _prepare_instructions(inf):
    instruction_number = 1
    for line_number, line in enumerate(inf, start=1):
        line = line.strip().split('//')[0]
        if len(line) == 0 or line.startswith('//'):
            continue
        else:
            instruction = line
            yield (instruction, line_number, instruction_number)
            instruction_number += 1

def _increment_stack_pointer(outf):
    _write_asm_comment(outf,
                       "increment stack pointer")

    _write_asm_instruction(outf, "@SP")
    _write_asm_instruction(outf, "M = M + 1\n")

def _decrement_stack_pointer(outf):
    _write_asm_comment(outf,
                       "decrement stack pointer")

    _write_asm_instruction(outf, "@SP")
    _write_asm_instruction(outf, "M = M - 1\n")



def _process_push(outf, source, index, line_number):
    try:
        index = int(index)
    except ValueError:
        _raise_error(f"Third field must contain an int but contains {index}.",
                     line_number)

    if source == 'constant':
        _write_asm_instruction(outf, f"@{index}")
        _write_asm_instruction(outf,  "D = A")
        _write_asm_instruction(outf,  "@SP")
        _write_asm_instruction(outf,  "A = M")
        _write_asm_instruction(outf,  "M = D\n")

    _increment_stack_pointer(outf)

def _process_add(outf, line_number):
    _write_asm_comment(outf, "start add")

    _decrement_stack_pointer(outf)

    _write_asm_instruction(outf, "@SP")
    _write_asm_instruction(outf, "A = M")
    _write_asm_instruction(outf, "D = M\n")

    _decrement_stack_pointer(outf)

    _write_asm_instruction(outf, "@SP")
    _write_asm_instruction(outf, "A = M")
    _write_asm_instruction(outf, "M = M + D")

    _increment_stack_pointer(outf)

    _write_asm_comment(outf, "end add\n")

def _end_program(outf):
    _write_asm_comment(outf,
                       "end program")

    _write_asm_instruction(outf, "(INFINITE_LOOP)")
    _write_asm_instruction(outf, "@INFINITE_LOOP")
    _write_asm_instruction(outf, "0;JMP\n")

def vm_translator(input_fp,
                  output_fp,
                  verbose=False):
    """
    """

    with open(input_fp) as inf, \
         open(output_fp, 'w') as outf:

        inst_generator = _prepare_instructions(inf)
        for (instruction, line_number, instruction_number) in inst_generator:
            fields = instruction.split()
            print(fields)
            n_fields = len(fields)
            if n_fields > 3:
                _raise_error("More than three fields found on line "
                             f"{line_number}.")
            elif n_fields == 3:
                if fields[0] == 'push':
                    _process_push(outf, fields[1], fields[2], line_number)
            elif n_fields == 2:
                raise NotImplementedError
            else:
                if fields[0] == 'add':
                    _process_add(outf, line_number)

        _end_program(outf)







if __name__ == "__main__":
    if len(sys.argv) == 1 or '--help' in sys.argv or '-h' in sys.argv:
        _print_usage(program_name=pathlib.Path(sys.argv[0]).name)
        exit(0)

    verbose = '--verbose' in sys.argv

    input_fp = pathlib.Path(sys.argv[-1])

    if not input_fp.exists():
        raise ValueError(f"Input path doesn't exist: {input_fp}")

    if not input_fp.suffix == '.vm':
        raise ValueError(
            "Input path must have extension .vm, "
            f"but found {input_fp.suffix}")

    output_fp = input_fp.with_suffix('.asm')

    if verbose:
        print(f"Input path: {input_fp}")
        print(f"Output path: {output_fp}")

    vm_translator(input_fp, output_fp, verbose=verbose)